#!/usr/bin/env node

/**
 * AQE - Agentic Quality Engineering Fleet CLI
 *
 * Complete implementation with all functions included
 * User-friendly shorthand for comprehensive QE operations
 */

const path = require('path');
const fs = require('fs');
const { spawn } = require('child_process');
const { promisify } = require('util');
const chalk = require('chalk');

/**
 * Copy comprehensive agent template from agentic-qe package
 * @param {string} agentName - Name of the agent
 * @param {string} targetDir - Target directory for agent creation
 */
function copyAgentTemplate(agentName, targetDir = process.cwd()) {
  // Security: Validate and sanitize directory path
  const sanitizedTargetDir = path.resolve(targetDir);
  if (!isAllowedDirectory(sanitizedTargetDir)) {
    throw new Error(`Access denied: ${targetDir} is not an allowed directory`);
  }

  // Find source template (comprehensive agent definition)
  const possibleSources = [
    path.join(__dirname, '..', '.claude', 'agents', `${agentName}.md`),  // Same package
    path.join(process.cwd(), 'node_modules', 'agentic-qe', '.claude', 'agents', `${agentName}.md`),  // Installed
    path.join(process.cwd(), '..', 'agentic-qe', '.claude', 'agents', `${agentName}.md`)  // Monorepo
  ];

  let sourceTemplate = null;
  for (const src of possibleSources) {
    if (fs.existsSync(src)) {
      sourceTemplate = src;
      break;
    }
  }

  const targetPath = path.join(sanitizedTargetDir, '.claude', 'agents', `${agentName}.md`);

  if (sourceTemplate) {
    // Copy the comprehensive agent template
    fs.copyFileSync(sourceTemplate, targetPath);
    console.log(chalk.green(`‚úÖ Registered agent: ${agentName} ${chalk.gray('(comprehensive template)')}`));
  } else {
    // Fallback to basic template if comprehensive not found
    console.log(chalk.yellow(`‚ö†Ô∏è  Comprehensive template not found for ${agentName}, using basic template`));
    registerAgentBasic(agentName, targetDir);
  }

  return targetPath;
}

/**
 * Fallback: Register basic agent if comprehensive template not found
 * @param {string} agentName - Name of the agent
 * @param {string} targetDir - Target directory
 */
function registerAgentBasic(agentName, targetDir = process.cwd()) {
  const agentPath = path.join(targetDir, '.claude', 'agents', `${agentName}.md`);
  const agentType = agentName.replace('qe-', '');

  const capabilities = {
    'qe-test-generator': ['AI-powered test generation', 'Property-based testing', 'Coverage-driven generation'],
    'qe-test-executor': ['Parallel test execution', 'Retry logic', 'Real-time reporting'],
    'qe-coverage-analyzer': ['O(log n) optimization', 'Gap identification', 'Critical path analysis'],
    'qe-quality-gate': ['Threshold enforcement', 'Go/no-go decisions', 'Risk assessment'],
    'qe-performance-tester': ['Load testing', 'Bottleneck detection', 'SLA validation'],
    'qe-security-scanner': ['SAST/DAST integration', 'Vulnerability detection', 'CVE monitoring']
  };

  const caps = capabilities[agentName] || ['Quality engineering'];

  const agentContent = `# ${agentName}

Type: ${agentType}
Status: Active

## Capabilities
${caps.map(cap => `- ${cap}`).join('\n')}

## Description
This is an Agentic QE Fleet agent specialized in ${agentType}.

## Commands
- Initialize: \`aqe agent spawn --name ${agentName} --type ${agentType}\`
- Execute: \`aqe agent execute --name ${agentName} --task "<task>"\`
- Status: \`aqe agent status --name ${agentName}\`

## Integration
This agent integrates with the Agentic QE Fleet through:
- EventBus for coordination
- MemoryManager for state persistence
- FleetManager for lifecycle management
`;

  fs.writeFileSync(agentPath, agentContent);
  console.log(chalk.green(`‚úÖ Registered agent: ${agentName} ${chalk.gray('(basic template)')}`));
}

/**
 * Security: Path validation function
 */
function isAllowedDirectory(dirPath) {
  const resolvedPath = path.resolve(dirPath);
  const workspaceRoot = path.resolve('/workspaces');
  const homeDir = path.resolve(process.env.HOME || '/tmp');

  // Allow only paths within workspace or user home directory
  return resolvedPath.startsWith(workspaceRoot) || resolvedPath.startsWith(homeDir);
}

/**
 * Security: Execute command safely using spawn
 */
function executeCommand(command, args = [], options = {}) {
  return new Promise((resolve, reject) => {
    const child = spawn(command, args, {
      stdio: options.stdio || 'pipe',
      cwd: options.cwd || process.cwd(),
      env: { ...process.env, ...options.env }
    });

    let stdout = '';
    let stderr = '';

    if (child.stdout) {
      child.stdout.on('data', (data) => {
        stdout += data.toString();
        if (options.stdio === 'inherit') {
          process.stdout.write(data);
        }
      });
    }

    if (child.stderr) {
      child.stderr.on('data', (data) => {
        stderr += data.toString();
        if (options.stdio === 'inherit') {
          process.stderr.write(data);
        }
      });
    }

    child.on('close', (code) => {
      if (code === 0) {
        resolve({ stdout, stderr, code });
      } else {
        reject(new Error(`Command failed with code ${code}: ${stderr}`));
      }
    });

    child.on('error', (error) => {
      reject(error);
    });
  });
}

/**
 * Copy command definitions from agentic-qe package to project
 * @param {string} targetDir - Target directory for command creation
 */
function copyCommandDefinitions(targetDir = process.cwd()) {
  // Security: Validate and sanitize directory path
  const sanitizedTargetDir = path.resolve(targetDir);
  if (!isAllowedDirectory(sanitizedTargetDir)) {
    throw new Error(`Access denied: ${targetDir} is not an allowed directory`);
  }

  const targetCommandsDir = path.join(sanitizedTargetDir, '.claude', 'commands');

  // Create commands directory if it doesn't exist
  if (!fs.existsSync(targetCommandsDir)) {
    fs.mkdirSync(targetCommandsDir, { recursive: true });
  }

  // Define command names (8 QE slash commands)
  const commands = [
    'aqe-generate',
    'aqe-execute',
    'aqe-analyze',
    'aqe-optimize',
    'aqe-report',
    'aqe-fleet-status',
    'aqe-chaos',
    'aqe-benchmark'
  ];

  // Search for command templates in multiple possible locations
  const possibleSourceDirs = [
    path.join(__dirname, '..', '.claude', 'commands'),           // Same package
    path.join(process.cwd(), 'node_modules', 'agentic-qe', '.claude', 'commands'), // Installed
    path.join(process.cwd(), '..', 'agentic-qe', '.claude', 'commands')  // Monorepo
  ];

  let sourceCommandsDir = null;
  for (const src of possibleSourceDirs) {
    if (fs.existsSync(src)) {
      sourceCommandsDir = src;
      break;
    }
  }

  console.log(chalk.cyan('\nüìã Setting up QE slash commands...\n'));

  let copiedCount = 0;
  let createdCount = 0;

  commands.forEach(commandName => {
    const targetPath = path.join(targetCommandsDir, `${commandName}.md`);

    // Skip if command already exists
    if (fs.existsSync(targetPath)) {
      console.log(chalk.gray(`   ${commandName}.md already exists (skipped)`));
      return;
    }

    // Try to copy from source
    if (sourceCommandsDir) {
      const sourcePath = path.join(sourceCommandsDir, `${commandName}.md`);
      if (fs.existsSync(sourcePath)) {
        fs.copyFileSync(sourcePath, targetPath);
        console.log(chalk.green(`‚úÖ Copied command: ${commandName}.md`));
        copiedCount++;
        return;
      }
    }

    // Fallback: Create basic command stub
    const commandStub = generateCommandStub(commandName);
    fs.writeFileSync(targetPath, commandStub);
    console.log(chalk.yellow(`‚ö†Ô∏è  Created stub: ${commandName}.md (template not found)`));
    createdCount++;
  });

  console.log(chalk.gray(`\n   Commands copied: ${copiedCount}, Stubs created: ${createdCount}`));
  return { copiedCount, createdCount };
}

/**
 * Generate a basic command stub if template not found
 * @param {string} commandName - Name of the command
 */
function generateCommandStub(commandName) {
  const commandType = commandName.replace('aqe-', '');

  return `# ${commandName}

**Command Type:** ${commandType}
**Status:** Stub (requires implementation)

## Overview
This is a placeholder for the ${commandName} command. Full implementation coming soon.

## Usage
\`\`\`bash
/${commandName} [options]
\`\`\`

## Implementation
This command integrates with:
- Claude Flow hooks
- AQE Fleet agents
- Memory coordination

For full implementation, see the AQE documentation.
`;
}

/**
 * Create settings.json with hook configuration
 * @param {string} targetDir - Target directory for settings.json
 */
function createSettingsJson(targetDir = process.cwd()) {
  // Security: Validate and sanitize directory path
  const sanitizedTargetDir = path.resolve(targetDir);
  if (!isAllowedDirectory(sanitizedTargetDir)) {
    throw new Error(`Access denied: ${targetDir} is not an allowed directory`);
  }

  const settingsPath = path.join(sanitizedTargetDir, '.claude', 'settings.json');

  // Skip if settings.json already exists
  if (fs.existsSync(settingsPath)) {
    console.log(chalk.yellow('\n‚ö†Ô∏è  settings.json already exists (skipped)'));
    return;
  }

  const settings = {
    version: "1.0.0",
    hooks: {
      enabled: true,
      preToolUse: {
        enabled: true,
        commands: [
          "npx claude-flow@alpha hooks pre-task --description \"{{description}}\" --agent \"{{agent}}\""
        ]
      },
      postToolUse: {
        enabled: true,
        commands: [
          "npx claude-flow@alpha hooks post-task --task-id \"{{task_id}}\" --results \"{{results}}\""
        ]
      },
      postEdit: {
        enabled: true,
        commands: [
          "npx claude-flow@alpha hooks post-edit --file \"{{file}}\" --memory-key \"aqe/files/{{file_name}}\""
        ]
      }
    },
    environment: {
      CLAUDE_FLOW_HOOKS_ENABLED: "true",
      AQE_FLEET_ENABLED: "true",
      AQE_MEMORY_NAMESPACE: "aqe"
    },
    permissions: {
      allowedCommands: [
        "aqe-generate",
        "aqe-execute",
        "aqe-analyze",
        "aqe-optimize",
        "aqe-report",
        "aqe-fleet-status",
        "aqe-chaos",
        "aqe-benchmark"
      ]
    },
    customPrompts: {
      testGeneration: "Generate comprehensive tests following TDD best practices",
      coverageAnalysis: "Use sublinear algorithms for efficient coverage analysis",
      qualityGate: "Enforce quality thresholds: 95% coverage, <15 complexity"
    }
  };

  fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2));
  console.log(chalk.green('\n‚úÖ Created settings.json with hook configuration'));
  console.log(chalk.gray(`   File: ${settingsPath}`));
}

/**
 * Create fleet configuration file
 * @param {object} config - Fleet configuration
 * @param {string} targetDir - Target directory
 */
function createFleetConfig(config, targetDir = process.cwd()) {
  // Security: Validate and sanitize directory path
  const sanitizedTargetDir = path.resolve(targetDir);
  if (!isAllowedDirectory(sanitizedTargetDir)) {
    throw new Error(`Access denied: ${targetDir} is not an allowed directory`);
  }

  const configPath = path.join(sanitizedTargetDir, '.claude', 'aqe-fleet.json');

  const fleetConfig = {
    fleetId: config.fleetId || `aqe-fleet-${Date.now()}`,
    version: "2.0.0",
    topology: config.topology || 'hierarchical',
    maxAgents: config.maxAgents || 6,
    agents: config.agents || [],
    created: new Date().toISOString(),
    status: 'active',
    configuration: {
      coordination: {
        memoryNamespace: 'aqe',
        hooksEnabled: true,
        neuralLearning: true
      },
      testing: {
        defaultFramework: 'jest',
        coverageThreshold: 95,
        parallelWorkers: 'auto'
      },
      optimization: {
        algorithm: 'sublinear',
        targetCoveragePerTest: 'maximize'
      }
    },
    metadata: {
      packageVersion: '2.0.0',
      claudeFlowVersion: 'alpha',
      initDate: new Date().toISOString()
    }
  };

  fs.writeFileSync(configPath, JSON.stringify(fleetConfig, null, 2));
  console.log(chalk.green('\n‚úÖ Created fleet configuration'));
  console.log(chalk.gray(`   File: ${configPath}`));

  return fleetConfig;
}

/**
 * Update CLAUDE.md in target project with AQE rules
 */
function updateClaudeMD(targetDir = process.cwd()) {
  // Security: Validate and sanitize directory path
  const sanitizedTargetDir = path.resolve(targetDir);
  if (!isAllowedDirectory(sanitizedTargetDir)) {
    throw new Error(`Access denied: ${targetDir} is not an allowed directory`);
  }
  const claudeMdPath = path.join(sanitizedTargetDir, 'CLAUDE.md');

  console.log(chalk.cyan('\nüìù Updating CLAUDE.md with AQE rules...\n'));

  // AQE rules to add
  const aqeRules = `

## üöÄ AGENTIC QE FLEET - CRITICAL RULES

### üì¶ Project Structure
**The AQE implementation is in \`/agentic-qe/\` subfolder by design:**
- This is a modular monorepo pattern
- Core AQE system is separate from projects using it
- This allows:
  - Centralized QE agent management
  - Reusability across multiple projects
  - Clean separation of concerns
  - Easy updates and maintenance

### ü§ñ Available QE Agents
- **qe-test-generator**: AI-powered test creation with property-based testing
- **qe-test-executor**: Parallel test execution with retry logic
- **qe-coverage-analyzer**: O(log n) coverage optimization with gap detection
- **qe-quality-gate**: Intelligent go/no-go decisions with risk assessment
- **qe-performance-tester**: Load testing and bottleneck detection
- **qe-security-scanner**: SAST/DAST integration with CVE monitoring

### ‚ö° Agent Usage
**Spawn agents via Claude Code Task tool:**
\`\`\`javascript
Task("Generate tests", "Create comprehensive test suite", "qe-test-generator")
Task("Execute tests", "Run tests in parallel", "qe-test-executor")
Task("Analyze coverage", "Find coverage gaps", "qe-coverage-analyzer")
\`\`\`

**Or use MCP tools for coordination:**
\`\`\`javascript
mcp__agentic_qe__fleet_init({ topology: "hierarchical" })
mcp__agentic_qe__test_generate({ framework: "jest", coverage: 0.95 })
\`\`\`

### üéØ Best Practices
1. **Initialize Fleet First**: Run \`aqe init\` before using agents
2. **Use Parallel Execution**: Spawn multiple agents in single messages
3. **Leverage Memory**: Agents share state via Claude Flow memory
4. **Monitor Progress**: Check agent status with \`aqe status\`
5. **Claude Flow Integration**: Agents use hooks for coordination

### ‚ö†Ô∏è Common Pitfalls
- Don't expect agents in root .claude/agents/ - they're in project's .claude/agents/
- Real vs Mock: \`aqe init\` creates real agents (not mocked demos)
- Hooks are intentional: Agents coordinate via Claude Flow hooks
- Memory is shared: All agents can access aqe/* memory keys

### üîß Commands
- \`aqe init\` - Initialize AQE fleet in current project
- \`aqe status\` - Show fleet status
- \`aqe test <module>\` - Generate tests for a module
- \`aqe coverage\` - Analyze test coverage
- \`aqe quality\` - Run quality gate check
- \`aqe agent spawn --name <agent>\` - Spawn specific agent
- \`aqe agent execute --name <agent> --task "<task>"\` - Execute task

---

*Agentic QE Fleet - Enterprise-grade quality engineering powered by AI and sublinear algorithms*
`;

  // Check if CLAUDE.md exists
  if (fs.existsSync(claudeMdPath)) {
    let content = fs.readFileSync(claudeMdPath, 'utf-8');

    // Check if AQE rules already exist
    if (content.includes('AGENTIC QE FLEET - CRITICAL RULES')) {
      console.log(chalk.yellow('‚ö†Ô∏è  AQE rules already exist in CLAUDE.md'));
      console.log(chalk.cyan('   Updating existing rules...'));

      // Replace existing AQE section
      const startMarker = '## üöÄ AGENTIC QE FLEET - CRITICAL RULES';
      const endMarker = '*Agentic QE Fleet - Enterprise-grade quality engineering powered by AI and sublinear algorithms*';

      const startIndex = content.indexOf(startMarker);
      if (startIndex !== -1) {
        const endIndex = content.indexOf(endMarker, startIndex);
        if (endIndex !== -1) {
          const before = content.substring(0, startIndex);
          const after = content.substring(endIndex + endMarker.length);
          content = before + aqeRules.trim() + after;
        }
      }
    } else {
      // Append AQE rules to existing CLAUDE.md
      content += aqeRules;
    }

    fs.writeFileSync(claudeMdPath, content);
    console.log(chalk.green('‚úÖ Updated existing CLAUDE.md with AQE rules'));
  } else {
    // Create new CLAUDE.md with AQE rules
    const defaultContent = `# Claude Code Configuration

## Project Overview
This project uses Agentic QE Fleet for comprehensive quality engineering.
${aqeRules}`;

    fs.writeFileSync(claudeMdPath, defaultContent);
    console.log(chalk.green('‚úÖ Created new CLAUDE.md with AQE rules'));
  }

  console.log(chalk.gray(`   File: ${claudeMdPath}`));
}

/**
 * Initialize the AQE Fleet with real agents
 * @param {string} targetDir - Target directory for initialization (defaults to current directory)
 */
async function initializeFleet(targetDir = process.cwd()) {
  console.log(chalk.cyan('\nüöÄ Initializing Agentic QE Fleet...\n'));

  // Security: Validate and sanitize directory path
  const sanitizedTargetDir = path.resolve(targetDir);
  if (!isAllowedDirectory(sanitizedTargetDir)) {
    throw new Error(`Access denied: ${targetDir} is not an allowed directory`);
  }

  console.log(chalk.gray(`Target directory: ${sanitizedTargetDir}\n`));

  // Ensure Claude agents directory exists in target directory
  const targetClaudeDir = path.join(sanitizedTargetDir, '.claude', 'agents');
  if (!fs.existsSync(targetClaudeDir)) {
    fs.mkdirSync(targetClaudeDir, { recursive: true });
  }

  // Define AQE agent types
  // Complete 16-agent AQE Fleet
  const aqeAgents = [
    // Core Testing Agents (6)
    {
      name: 'qe-test-generator',
      type: 'test-generator',
      capabilities: [
        'AI-powered test generation',
        'Property-based testing',
        'Boundary value analysis',
        'Coverage-driven generation',
        'Multi-framework support (Jest, Mocha, Cypress)'
      ]
    },
    {
      name: 'qe-test-executor',
      type: 'test-executor',
      capabilities: [
        'Parallel test execution',
        'Retry logic for flaky tests',
        'Real-time reporting',
        'Framework integration',
        'Resource optimization'
      ]
    },
    {
      name: 'qe-coverage-analyzer',
      type: 'coverage-analyzer',
      capabilities: [
        'O(log n) coverage optimization',
        'Gap identification',
        'Critical path analysis',
        'Sublinear algorithms',
        'Coverage trend analysis'
      ]
    },
    {
      name: 'qe-quality-gate',
      type: 'quality-gate',
      capabilities: [
        'Threshold enforcement',
        'Go/no-go decisions',
        'Risk assessment',
        'Policy validation',
        'Automated approvals'
      ]
    },
    {
      name: 'qe-performance-tester',
      type: 'performance-tester',
      capabilities: [
        'Load testing orchestration',
        'Bottleneck detection',
        'Resource monitoring',
        'SLA validation',
        'Performance regression detection'
      ]
    },
    {
      name: 'qe-security-scanner',
      type: 'security-scanner',
      capabilities: [
        'SAST/DAST integration',
        'Vulnerability detection',
        'Compliance checking',
        'Security test generation',
        'CVE monitoring'
      ]
    },
    // Specialized Testing Agents (3)
    {
      name: 'qe-fleet-commander',
      type: 'fleet-commander',
      capabilities: [
        'Hierarchical coordination',
        'Resource allocation',
        'Dynamic topology management',
        'Conflict resolution',
        'Auto-scaling'
      ]
    },
    {
      name: 'qe-chaos-engineer',
      type: 'chaos-engineer',
      capabilities: [
        'Fault injection',
        'Recovery testing',
        'Blast radius control',
        'Experiment orchestration',
        'Safety validation'
      ]
    },
    {
      name: 'qe-visual-tester',
      type: 'visual-tester',
      capabilities: [
        'Screenshot comparison',
        'Visual regression detection',
        'Accessibility validation',
        'Cross-browser testing',
        'Semantic analysis'
      ]
    },
    // Strategic Planning Agents (P0 - Critical) (3)
    {
      name: 'qe-requirements-validator',
      type: 'requirements-validator',
      capabilities: [
        'Testability analysis',
        'BDD scenario generation',
        'Risk assessment',
        'Acceptance criteria validation',
        'Traceability mapping'
      ]
    },
    {
      name: 'qe-deployment-readiness',
      type: 'deployment-validator',
      capabilities: [
        'Risk scoring',
        'Release confidence calculation',
        'Checklist automation',
        'Rollback prediction',
        'Stakeholder reporting'
      ]
    },
    {
      name: 'qe-production-intelligence',
      type: 'production-analyzer',
      capabilities: [
        'Incident replay testing',
        'RUM analysis',
        'Anomaly detection',
        'Load pattern analysis',
        'Feature usage analytics'
      ]
    },
    // Optimization Agents (P1 - High Value) (4)
    {
      name: 'qe-regression-risk-analyzer',
      type: 'regression-analyzer',
      capabilities: [
        'Change impact analysis',
        'Test selection optimization',
        'Risk heat mapping',
        'Dependency tracking',
        'Historical pattern learning'
      ]
    },
    {
      name: 'qe-test-data-architect',
      type: 'data-generator',
      capabilities: [
        'Schema-aware generation',
        'Relationship preservation',
        'Edge case data',
        'Data anonymization',
        'Realistic data synthesis'
      ]
    },
    {
      name: 'qe-api-contract-validator',
      type: 'contract-validator',
      capabilities: [
        'Schema validation',
        'Breaking change detection',
        'Version compatibility',
        'Contract diffing',
        'Consumer impact analysis'
      ]
    },
    {
      name: 'qe-flaky-test-hunter',
      type: 'flaky-test-detector',
      capabilities: [
        'Flaky detection',
        'Root cause analysis',
        'Auto-stabilization',
        'Quarantine management',
        'Trend tracking'
      ]
    }
  ];

  // Copy comprehensive agent templates
  console.log(chalk.bold('Registering AQE agents with Claude Code:\n'));
  aqeAgents.forEach(agent => {
    copyAgentTemplate(agent.name, targetDir);
  });

  // Copy command definitions (8 QE slash commands)
  copyCommandDefinitions(targetDir);

  // Create settings.json with hook configuration
  createSettingsJson(targetDir);

  // Create fleet configuration with all metadata
  const fleetConfig = createFleetConfig({
    fleetId: `aqe-fleet-${Date.now()}`,
    topology: 'hierarchical',
    maxAgents: 6,
    agents: aqeAgents.map(a => a.name)
  }, targetDir);

  console.log(chalk.cyan('\nüìã Fleet Configuration:'));
  console.log(`  Fleet ID: ${chalk.green(fleetConfig.fleetId)}`);
  console.log(`  Topology: ${chalk.green(fleetConfig.topology)}`);
  console.log(`  Agents: ${chalk.green(fleetConfig.agents.length)}`);
  console.log(`  Commands: ${chalk.green('8 QE slash commands')}`);
  console.log(`  Hooks: ${chalk.green('Enabled via settings.json')}`);

  // Update CLAUDE.md with AQE rules
  updateClaudeMD(targetDir);

  // Initialize with Claude Flow hooks using secure execution
  console.log(chalk.cyan('\nüîó Integrating with Claude Flow...\n'));
  try {
    await executeCommand('npx', ['claude-flow@alpha', 'hooks', 'pre-task', '--description', 'AQE Fleet Initialization'], { stdio: 'inherit' });
    await executeCommand('npx', ['claude-flow@alpha', 'memory', 'store', '--key', 'aqe/fleet/id', '--value', fleetConfig.fleetId], { stdio: 'inherit' });
    await executeCommand('npx', ['claude-flow@alpha', 'hooks', 'notify', '--message', 'AQE Fleet initialized with real agents'], { stdio: 'inherit' });
  } catch (error) {
    console.log(chalk.yellow('‚ö†Ô∏è  Claude Flow integration optional - continuing...'));
  }

  console.log(chalk.green('\n‚úÖ AQE Fleet successfully initialized!'));
  console.log(chalk.gray('\nAgents are now available in: .claude/agents/'));
  console.log(chalk.gray('Use Claude Code to interact with these agents.\n'));
}

/**
 * Show fleet status
 */
function showFleetStatus() {
  console.log(chalk.cyan('\nüìä AQE Fleet Status\n'));

  const configPath = path.join(process.cwd(), '.claude', 'aqe-fleet.json');

  if (!fs.existsSync(configPath)) {
    console.log(chalk.red('‚ùå Fleet not initialized. Run: aqe init'));
    return;
  }

  const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));

  console.log(`Fleet ID: ${chalk.green(config.fleetId)}`);
  console.log(`Status: ${chalk.green(config.status)}`);
  console.log(`Created: ${chalk.gray(config.created)}`);
  console.log(`Topology: ${chalk.green(config.topology)}`);

  console.log(chalk.bold('\nü§ñ Registered Agents:'));
  const CLAUDE_AGENTS_DIR = path.join(process.cwd(), '.claude', 'agents');
  config.agents.forEach(agentName => {
    const agentPath = path.join(CLAUDE_AGENTS_DIR, `${agentName}.md`);
    const exists = fs.existsSync(agentPath);
    const status = exists ? chalk.green('‚úì Active') : chalk.red('‚úó Missing');
    console.log(`  ${agentName}: ${status}`);
  });

  console.log(chalk.cyan('\nüí° Quick Commands:'));
  console.log('  aqe test <module>   - Generate tests');
  console.log('  aqe coverage        - Analyze coverage');
  console.log('  aqe quality         - Check quality gates');
  console.log('  aqe agent execute   - Run agent task');
}

/**
 * Setup MCP integration
 */
function setupMCP() {
  console.log(chalk.cyan('\nüîß Setting up MCP Server for Claude Code...\n'));

  // Update package.json with MCP script
  const packagePath = path.join(process.cwd(), 'package.json');

  if (!fs.existsSync(packagePath)) {
    console.log(chalk.red('‚ùå No package.json found. Please run from project root.'));
    return;
  }

  const packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf-8'));

  packageJson.scripts = packageJson.scripts || {};
  packageJson.scripts['mcp:start'] = 'ts-node src/mcp/start.ts';
  packageJson.scripts['mcp:dev'] = 'nodemon --watch src/mcp -e ts --exec ts-node src/mcp/start.ts';

  fs.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2));
  console.log(chalk.green('‚úÖ Added MCP scripts to package.json'));

  console.log(chalk.cyan('\nTo connect AQE to Claude Code:'));
  console.log(chalk.bold('\n1. Add MCP server to Claude Code:'));
  console.log(chalk.gray('   claude mcp add agentic-qe "cd ' + process.cwd() + ' && npm run mcp:start"'));

  console.log(chalk.bold('\n2. Restart Claude Code to load MCP tools'));

  console.log(chalk.bold('\n3. Use MCP tools in Claude Code:'));
  console.log(chalk.gray('   - mcp__agentic_qe__fleet_init'));
  console.log(chalk.gray('   - mcp__agentic_qe__test_generate'));
  console.log(chalk.gray('   - mcp__agentic_qe__test_execute'));
  console.log(chalk.gray('   - mcp__agentic_qe__quality_analyze'));
}

// Get command and arguments
const command = process.argv[2];
const args = process.argv.slice(3);

// Handle commands - wrapped in async function for secure execution
async function handleCommand() {
  switch(command) {
  case 'init':
    // Initialize AQE Fleet
    const targetDir = args[0] || process.cwd();
    await initializeFleet(targetDir);
    break;

  case 'status':
    // Show fleet status
    showFleetStatus();
    break;

  case 'mcp':
    // Setup MCP server
    setupMCP();
    break;

  case 'agent':
    // Agent management commands - delegate to main agentic-qe using secure execution
    const mainScript = path.join(__dirname, 'agentic-qe');
    try {
      await executeCommand('node', [mainScript, 'agent', ...args], { stdio: 'inherit' });
    } catch (error) {
      console.error(chalk.red('Failed to execute agent command:'), error.message);
      process.exit(1);
    }
    break;

  case 'test':
    // Quick test generation
    if (!args.length) {
      console.log(chalk.red('‚ùå Please specify a module: aqe test <module>'));
      process.exit(1);
    }
    console.log(chalk.cyan(`\nüß™ Generating tests for: ${args.join(' ')}\n`));
    console.log(chalk.yellow('Using qe-test-generator agent...'));
    // TODO: Implement actual test generation
    console.log(chalk.gray('\nNote: Direct test generation coming soon.'));
    console.log(chalk.gray('For now, use: aqe agent execute --name qe-test-generator --task "generate tests for ' + args.join(' ') + '"'));
    break;

  case 'coverage':
    // Quick coverage analysis
    console.log(chalk.cyan('\nüìä Analyzing test coverage...\n'));
    console.log(chalk.yellow('Using qe-coverage-analyzer agent...'));
    // TODO: Implement actual coverage analysis
    console.log(chalk.gray('\nNote: Direct coverage analysis coming soon.'));
    console.log(chalk.gray('For now, use: aqe agent execute --name qe-coverage-analyzer --task "analyze coverage"'));
    break;

  case 'quality':
    // Quick quality gate check
    console.log(chalk.cyan('\n‚úÖ Running quality gate check...\n'));
    console.log(chalk.yellow('Using qe-quality-gate agent...'));
    // TODO: Implement actual quality gate
    console.log(chalk.gray('\nNote: Direct quality gate check coming soon.'));
    console.log(chalk.gray('For now, use: aqe agent execute --name qe-quality-gate --task "evaluate quality gate"'));
    break;

  case 'help':
  case '--help':
  case '-h':
  case undefined:
    // Show help
    console.log(chalk.cyan('\nüöÄ AQE - Agentic Quality Engineering Fleet\n'));
    console.log(chalk.bold('Usage:') + ' aqe <command> [options]\n');

    console.log(chalk.bold('Core Commands:'));
    console.log('  ' + chalk.green('init [dir]') + '      Initialize AQE Fleet in directory (updates CLAUDE.md)');
    console.log('  ' + chalk.green('status') + '          Show fleet status and registered agents');
    console.log('  ' + chalk.green('mcp') + '             Setup MCP server for Claude Code integration\n');

    console.log(chalk.bold('Quick Actions:'));
    console.log('  ' + chalk.green('test <module>') + '   Generate tests for a module');
    console.log('  ' + chalk.green('coverage') + '        Analyze test coverage');
    console.log('  ' + chalk.green('quality') + '         Run quality gate check\n');

    console.log(chalk.bold('Agent Management:'));
    console.log('  ' + chalk.green('agent spawn') + '     Spawn a QE agent');
    console.log('  ' + chalk.green('agent execute') + '   Execute agent task');
    console.log('  ' + chalk.green('agent status') + '    Check agent status\n');

    console.log(chalk.bold('Available Agents:'));
    console.log('  ‚Ä¢ qe-test-generator     - AI-powered test creation');
    console.log('  ‚Ä¢ qe-test-executor      - Parallel test execution');
    console.log('  ‚Ä¢ qe-coverage-analyzer  - O(log n) coverage optimization');
    console.log('  ‚Ä¢ qe-quality-gate       - Go/no-go decisions');
    console.log('  ‚Ä¢ qe-performance-tester - Load testing');
    console.log('  ‚Ä¢ qe-security-scanner   - SAST/DAST scanning\n');

    console.log(chalk.gray('Examples:'));
    console.log(chalk.gray('  aqe init                    # Initialize in current directory'));
    console.log(chalk.gray('  aqe init /my/project        # Initialize in specific directory'));
    console.log(chalk.gray('  aqe test user-service       # Generate tests for user-service'));
    console.log(chalk.gray('  aqe coverage                # Analyze test coverage'));
    console.log(chalk.gray('  aqe quality                 # Check quality gates\n'));

    console.log(chalk.dim('For detailed help on any command, use: aqe <command> --help'));
    console.log(chalk.dim('Documentation: https://github.com/agentic-qe/docs\n'));
    break;

  default:
    console.error(chalk.red(`Unknown command: ${command}`));
    console.log(chalk.yellow('\nRun "aqe help" to see available commands'));
    process.exit(1);
  }
}

// Execute command handler
handleCommand().catch(error => {
  console.error(chalk.red('Error executing command:'), error.message);
  process.exit(1);
});